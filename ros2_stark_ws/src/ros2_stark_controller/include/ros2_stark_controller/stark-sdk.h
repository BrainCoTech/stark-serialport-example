#ifndef STARK_SDK_H
#define STARK_SDK_H

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>

/// 内置手势1~6：张开、握拳、两只捏、三只捏、侧边捏、单指点
/// 自定义手势6个: 10~15
enum ActionSequenceId : uint8_t {
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_OPEN = 1,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_FIST = 2,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_PINCH_TWO = 3,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_PINCH_THREE = 4,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_PINCH_SIDE = 5,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_POINT = 6,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE1 = 10,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE2 = 11,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE3 = 12,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE4 = 13,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE5 = 14,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE6 = 15,
};

enum ForceLevel : uint8_t {
  FORCE_LEVEL_SMALL = 1,
  FORCE_LEVEL_NORMAL = 2,
  FORCE_LEVEL_FULL = 3,
};

enum LedColor : uint8_t {
  LED_COLOR_UNCHANGED = 0,
  LED_COLOR_R = 1,
  LED_COLOR_G = 2,
  LED_COLOR_RG = 3,
  LED_COLOR_B = 4,
  LED_COLOR_RB = 5,
  LED_COLOR_GB = 6,
  LED_COLOR_RGB = 7,
};

enum LedMode : uint8_t {
  LED_MODE_NONE = 0,
  LED_MODE_SHUTDOWN = 1,
  LED_MODE_KEEP = 2,
  LED_MODE_BLINK = 3,
  LED_MODE_ONE_SHOT = 4,
  LED_MODE_BLINK0_5HZ = 5,
  LED_MODE_BLINK2_HZ = 6,
};

enum LogLevel : uint8_t {
  LOG_LEVEL_ERROR = 0,
  LOG_LEVEL_WARN = 1,
  LOG_LEVEL_INFO = 2,
  LOG_LEVEL_DEBUG = 3,
  LOG_LEVEL_TRACE = 4,
};

enum PressState : uint8_t {
  PRESS_STATE_NONE = 0,
  PRESS_STATE_DOWN = 1,
  PRESS_STATE_UP = 2,
};

enum SkuType : uint8_t {
  SKU_TYPE_MEDIUM_RIGHT = 1,
  SKU_TYPE_MEDIUM_LEFT = 2,
  SKU_TYPE_SMALL_RIGHT = 3,
  SKU_TYPE_SMALL_LEFT = 4,
};

enum StarkFingerId : uint8_t {
  STARK_FINGER_ID_THUMB = 1,
  STARK_FINGER_ID_THUMB_AUX = 2,
  STARK_FINGER_ID_INDEX = 3,
  STARK_FINGER_ID_MIDDLE = 4,
  STARK_FINGER_ID_RING = 5,
  STARK_FINGER_ID_PINKY = 6,
};

enum StarkFirmwareType : uint8_t {
  STARK_FIRMWARE_TYPE_RS485_PROTOBUF = 0,
  STARK_FIRMWARE_TYPE_V1_STANDARD = 1,
  STARK_FIRMWARE_TYPE_V1_TOUCH = 2,
};

struct ModbusHandle;

/// 设备信息
/// sku_type: 设备类型，1: 右手 2: 左手
/// serial_number: 序列号
/// firmware_version: 固件版本
struct DeviceInfo {
  SkuType sku_type;
  const char *serial_number;
  const char *firmware_version;
};

struct MotorStatusData {
  uint8_t positions[6];
  int8_t speeds[6];
  int8_t currents[6];
  uint8_t states[6];
};

struct TouchSensorStatus {
  uint16_t normal_force1;
  uint16_t normal_force2;
  uint16_t normal_force3;
  uint16_t tangential_force1;
  uint16_t tangential_force2;
  uint16_t tangential_force3;
  uint16_t tangential_direction1;
  uint16_t tangential_direction2;
  uint16_t tangential_direction3;
  uint32_t self_proximity1;
  uint32_t self_proximity2;
  uint32_t mutual_proximity;
  uint16_t status;
};

struct TouchStatusData {
  TouchSensorStatus data[5];
};

struct TurboConfig {
  uint16_t interval;
  uint16_t duration;
};

struct LedInfo {
  LedColor color;
  LedMode mode;
};

struct ButtonPressEvent {
  int32_t timestamp;
  int32_t button_id;
  PressState press_state;
};

extern "C" {

/// 初始化日志选项
/// 初始化选项
/// fw_type: 固件类型, V1Touch, V1Standard，默认为 V1Touch
/// log_level: 日志级别，默认为 Info
void init_cfg(StarkFirmwareType fw_type, LogLevel log_level);

/// 列出可用的串口
/// 用于列出所有的 Stark 串口
void list_available_ports();

/// 打开串口
/// port: 串口名称，例如："/dev/ttyUSB0", "COM1"
/// baudrate: 波特率，115200, 57600, 19200, 460800
/// slave_id: 设备ID，默认为1，范围为1~247, 0 为广播地址
/// 返回 ModbusHandle 结构体指针，关闭时需要调用 modbus_close 释放内存
/// 如果失败，返回 NULL
ModbusHandle *modbus_open(const char *port, uint32_t baudrate, uint8_t slave_id);

/// 关闭串口
void modbus_close(ModbusHandle *handle);

/// 获取设备信息
/// 返回 DeviceInfo 结构体指针，需要调用 free_device_info 释放内存
/// 如果失败，返回 NULL
DeviceInfo *modbus_get_device_info(ModbusHandle *handle, uint8_t slave_id);

/// 获取串口波特率
/// 115200, 57600, 19200, 460800
uint32_t modbus_get_baudrate(ModbusHandle *handle, uint8_t slave_id);

/// 设置串口波特率
/// 115200, 57600, 19200, 460800
void modbus_set_baudrate(ModbusHandle *handle, uint8_t slave_id, uint32_t baudrate);

/// 设置设备ID，默认为1，范围为1~247, 0 为广播地址
/// 当需要在一条总线上同时控制多只设备时，需要将设备ID设置为不同的值
/// 例如：设备1的ID为1，设备2的ID为2，设备3的ID为3
/// 通过广播地址0，可以同时控制总线上的所有设备，Mobbus协议规定广播地址的设备不会回复
void modbus_set_slave_id(ModbusHandle *handle,
                         uint8_t slave_id,
                         uint8_t new_id);

/// 获取设备ID，默认为1，范围为1~247, 0 为广播地址
/// 设置力量等级
void modbus_set_force_level(ModbusHandle *handle, uint8_t slave_id, ForceLevel level);

/// 获取力量等级
uint8_t modbus_get_force_level(ModbusHandle *handle, uint8_t slave_id);

/// 获取电压值，单位mV
uint16_t modbus_get_voltage(ModbusHandle *handle, uint8_t slave_id);

/// 设置手指位置
/// position: 位置值，范围为0~100
void modbus_set_finger_position(ModbusHandle *handle,
                                uint8_t slave_id,
                                StarkFingerId finger_id,
                                uint16_t position);

/// 设置手指位置
/// positions: 位置值数组，长度为6，范围为0~100
void modbus_set_finger_positions(ModbusHandle *handle,
                                 uint8_t slave_id,
                                 const uint16_t *positions,
                                 uintptr_t len);

/// 设置手指速度
/// speed: 速度值，范围为-100~100
void modbus_set_finger_speed(ModbusHandle *handle,
                             StarkFingerId finger_id,
                             uint8_t slave_id,
                             int16_t speed);

/// 设置手指速度
/// speeds: 速度值数组，长度为6，范围为-100~100
void modbus_set_finger_speeds(ModbusHandle *handle,
                              uint8_t slave_id,
                              const int16_t *speeds,
                              uintptr_t len);

/// 获取手指状态
/// 位置、速度、电流、马达运行状态
/// 返回 MotorStatusData 结构体指针，需要调用 free_motor_status_data 释放内存
/// 如果失败，返回 NULL
MotorStatusData *modbus_get_motor_status(ModbusHandle *handle, uint8_t slave_id);

/// 运行动作序列
/// action_id: 动作序列ID
void modbus_run_action_sequence(ModbusHandle *handle, uint8_t slave_id, ActionSequenceId action_id);

/// 传输动作序列
///
/// 该函数用于传输多个动作序列。每个动作序列包含 20 个元素，依次为：
///
/// - action_id: 动作序列的 ID，用于唯一标识该动作序列
/// - sequences: 动作序列数组，包含多个动作序列，每个动作序列包含 20 个 u16 元素。每个序列包括以下信息：
///   - 动作序列索引 (u16)：动作序列的索引，用于标识该动作序列在队列中的位置
///   - 持续时间 (u16)：该动作序列的执行时间，单位为毫秒
///   - 手指位置 (u16): 6 个手指位置的值，范围为 0~100
///   - 手指速度 (u16): 6 个手指速度的值，范围为 0~100
///   - 手指力量 (u16): 6 个手指力量的值，范围为 0~100
///
/// 示例：
/// 假设我们有以下动作序列数组：
/// [0, 2000, 0, 0, 100, 100, 100, 100, 10, 20, 30, 40, 50, 60, 5, 10, 15, 20, 25, 30]
///
/// 解释：
/// - `0`: 动作序列索引
/// - `2000`: 动作序列持续时间，单位毫秒
/// - `0, 0, 100, 100, 100, 100`: 6 个手指位置
/// - `10, 20, 30, 40, 50, 60`: 6 个手指速度
/// - `5, 10, 15, 20, 25, 30`: 6 个手指力量
///
/// - len: 动作序列的数量，指定 sequences 数组的行数，即动作序列的数量
///
/// # 参数说明
/// - `action_id`: 动作序列的 ID，唯一标识该序列
/// - `sequences`: 一个指向动作序列的指针，表示多个动作序列的二维数组
/// - `len`: 动作序列的数量，表示二维数组的行数
///
/// # 错误处理
/// - 如果 `handle` 或 `sequences` 为 NULL，将直接返回，不进行处理
/// - 如果 `len` 大于最大限制（例如 32），会输出警告并提前返回
void modbus_set_action_sequence(ModbusHandle *handle,
                                uint8_t slave_id,
                                ActionSequenceId action_id,
                                const uint16_t *sequences,
                                uintptr_t len);

/// 获取触觉传感器状态
/// 返回5个手指的触觉三维力数据
/// 使用完毕后需要调用 free_touch_status_data 释放内存
/// 如果失败，返回 NULL
TouchStatusData *modbus_get_touch_status(ModbusHandle *handle, uint8_t slave_id);

/// 启用触觉传感器
/// bits: 启用的触觉传感器位，范围为0~31
/// 例如：0b00000001 表示仅启用大拇指位置的触觉传感器
void modbus_enable_touch_sensor(ModbusHandle *handle, uint8_t slave_id, uint8_t bits);

/// 重置触觉传感器采集通道
/// 在执行该指令时，手指传感器尽量不要受力。
/// bits: 重置的触觉传感器位，范围为0~31
/// 例如：0b00000001 表示重置第一个传感器
void modbus_reset_touch_sensor(ModbusHandle *handle, uint8_t slave_id, uint8_t bits);

/// 触觉传感器参数校准
/// bits: 校准的触觉传感器位，范围为0~31
/// 例如：0b00000001 表示校准第一个传感器
/// 当空闲状态下的三维力数值不为0时，可通过该方法进行校准
/// https://www.brainco-hz.com/docs/revolimb-hand/protocol/modbus_protocol_touch.html#_5-3-%E5%8F%82%E6%95%B0%E6%A0%A1%E5%87%864105
void modbus_calibrate_touch_sensor(ModbusHandle *handle,
                                   uint8_t slave_id,
                                   uint8_t bits);

/// 在设备上电时，启用/禁用 位置自动校准
bool modbus_get_auto_calibration(ModbusHandle *handle, uint8_t slave_id);

/// 在设备上电时，启用/禁用 位置自动校准
void modbus_set_auto_calibration(ModbusHandle *handle, uint8_t slave_id, bool enabled);

/// 发送校准位置指令
/// 用于手动校准位置
void modbus_send_calibrate_position(ModbusHandle *handle, uint8_t slave_id);

/// 是否开启了 Turbo 模式
/// 开启之后会持续握紧
bool modbus_get_turbo_mode_enabled(ModbusHandle *handle, uint8_t slave_id);

/// 设置 Turbo 模式
void modbus_set_turbo_mode_enabled(ModbusHandle *handle, uint8_t slave_id, bool enabled);

/// 获取 Turbo 模式配置
/// 返回 TurboConfig 结构体指针，需要调用 free_turbo_config 释放内存
/// 如果失败，返回 NULL
TurboConfig *modbus_get_turbo_config(ModbusHandle *handle, uint8_t slave_id);

/// 获取 LED 灯信息
/// 返回 LedInfo 结构体指针，需要调用 free_led_info 释放内存
/// 如果失败，返回 NULL
LedInfo *modbus_get_led_info(ModbusHandle *handle, uint8_t slave_id);

/// 获取按键事件
/// 返回 ButtonPressEvent 结构体指针，需要调用 free_button_event 释放内存
/// 如果失败，返回 NULL
ButtonPressEvent *modbus_get_button_event(ModbusHandle *handle, uint8_t slave_id);

void free_device_info(DeviceInfo *info);

void free_motor_status_data(MotorStatusData *data);

void free_touch_status_data(TouchStatusData *status);

void free_turbo_config(TurboConfig *config);

void free_led_info(LedInfo *info);

void free_button_event(ButtonPressEvent *event);

void free_string(const char *s);

}  // extern "C"

#endif  // STARK_SDK_H
