#ifndef STARK_SDK_H
#define STARK_SDK_H

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>

/// 内置手势1~6：张开、握拳、两只捏、三只捏、侧边捏、单指点
/// 一代手最多支持6个自定义动作序列: 10~15
/// 二代手最多支持24个定义动作序列: 7~30
enum ActionSequenceId : uint8_t {
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_OPEN = 1,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_FIST = 2,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_PINCH_TWO = 3,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_PINCH_THREE = 4,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_PINCH_SIDE = 5,
  ACTION_SEQUENCE_ID_DEFAULT_GESTURE_POINT = 6,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE22 = 7,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE23 = 8,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE24 = 9,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE1 = 10,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE2 = 11,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE3 = 12,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE4 = 13,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE5 = 14,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE6 = 15,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE7 = 16,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE8 = 17,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE9 = 18,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE10 = 19,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE11 = 20,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE12 = 21,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE13 = 22,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE14 = 23,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE15 = 24,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE16 = 25,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE17 = 26,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE18 = 27,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE19 = 28,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE20 = 29,
  ACTION_SEQUENCE_ID_CUSTOM_GESTURE21 = 30,
};

enum ContactState : uint8_t {
  CONTACT_STATE_NO_CONTACT = 0,
  CONTACT_STATE_CONTACT = 1,
  CONTACT_STATE_CONTACT_SLIDING = 2,
};

enum EtherCATFoeType : uint8_t {
  ETHER_CAT_FOE_TYPE_WRIST = 1,
  ETHER_CAT_FOE_TYPE_CONTROL = 2,
};

enum FingerUnitMode : uint8_t {
  FINGER_UNIT_MODE_NORMALIZED = 0,
  FINGER_UNIT_MODE_PHYSICAL = 1,
};

enum ForceLevel : uint8_t {
  FORCE_LEVEL_SMALL = 1,
  FORCE_LEVEL_NORMAL = 2,
  FORCE_LEVEL_FULL = 3,
};

enum LedColor : uint8_t {
  LED_COLOR_UNCHANGED = 0,
  LED_COLOR_R = 1,
  LED_COLOR_G = 2,
  LED_COLOR_RG = 3,
  LED_COLOR_B = 4,
  LED_COLOR_RB = 5,
  LED_COLOR_GB = 6,
  LED_COLOR_RGB = 7,
};

enum LedMode : uint8_t {
  LED_MODE_NONE = 0,
  LED_MODE_SHUTDOWN = 1,
  LED_MODE_KEEP = 2,
  LED_MODE_BLINK = 3,
  LED_MODE_ONE_SHOT = 4,
  LED_MODE_BLINK0_5HZ = 5,
  LED_MODE_BLINK2_HZ = 6,
};

enum LogLevel : uint8_t {
  LOG_LEVEL_ERROR = 0,
  LOG_LEVEL_WARN = 1,
  LOG_LEVEL_INFO = 2,
  LOG_LEVEL_DEBUG = 3,
  LOG_LEVEL_TRACE = 4,
};

enum MotorState : uint8_t {
  MOTOR_STATE_IDLE = 0,
  MOTOR_STATE_RUNNING = 1,
  MOTOR_STATE_STALL = 2,
  MOTOR_STATE_TURBO = 3,
  MOTOR_STATE_UNKNOWN = 255,
};

enum PressState : uint8_t {
  PRESS_STATE_NONE = 0,
  PRESS_STATE_DOWN = 1,
  PRESS_STATE_UP = 2,
};

enum SkuType : uint8_t {
  SKU_TYPE_MEDIUM_RIGHT = 1,
  SKU_TYPE_MEDIUM_LEFT = 2,
  SKU_TYPE_SMALL_RIGHT = 3,
  SKU_TYPE_SMALL_LEFT = 4,
};

enum StarkFingerId : uint8_t {
  STARK_FINGER_ID_THUMB = 1,
  STARK_FINGER_ID_THUMB_AUX = 2,
  STARK_FINGER_ID_INDEX = 3,
  STARK_FINGER_ID_MIDDLE = 4,
  STARK_FINGER_ID_RING = 5,
  STARK_FINGER_ID_PINKY = 6,
};

enum StarkHardwareType : uint8_t {
  STARK_HARDWARE_TYPE_RS485_PROTOBUF = 0,
  STARK_HARDWARE_TYPE_REVO1_BASIC = 1,
  STARK_HARDWARE_TYPE_REVO1_TOUCH = 2,
  STARK_HARDWARE_TYPE_REVO2_BASIC = 3,
  STARK_HARDWARE_TYPE_REVO2_TOUCH = 4,
};

enum StarkProtocolType : uint8_t {
  STARK_PROTOCOL_TYPE_MODBUS = 1,
  STARK_PROTOCOL_TYPE_CAN = 2,
  STARK_PROTOCOL_TYPE_CAN_FD = 3,
  STARK_PROTOCOL_TYPE_ETHER_CAT = 4,
  STARK_PROTOCOL_TYPE_PROTOBUF = 5,
};

enum TouchSensorStatus : uint8_t {
  TOUCH_SENSOR_STATUS_NORMAL = 0,
  TOUCH_SENSOR_STATUS_ABNORMAL = 1,
  TOUCH_SENSOR_STATUS_COMMUNICATION_ERROR = 2,
  TOUCH_SENSOR_STATUS_UNKNOWN = 255,
};

struct DeviceHandler;

/// 设备配置
struct DeviceConfig {
  StarkProtocolType protocol;
  const char *port_name;
  uint32_t baudrate;
  uint8_t slave_id;
};

/// 设备信息
/// sku_type: 设备类型，1: 右手 2: 左手
/// serial_number: 序列号
/// firmware_version: 固件版本
struct DeviceInfo {
  StarkHardwareType hardware_type;
  SkuType sku_type;
  const char *serial_number;
  const char *firmware_version;
};

struct MotorStatusData {
  uint16_t positions[6];
  int16_t speeds[6];
  int16_t currents[6];
  uint8_t states[6];
};

struct TouchRawData {
  uint32_t thumb[7];
  uint32_t index[11];
  uint32_t middle[11];
  uint32_t ring[11];
  uint32_t pinky[7];
};

/// 触觉传感器数据
/// 三维力数值、自接近、互接近电容值，以及传感器状态
/// 二代触觉手只有法向力，切向力，切向力方向，接近值，四个值，其他值为0
struct TouchFingerItem {
  uint16_t normal_force1;
  uint16_t normal_force2;
  uint16_t normal_force3;
  uint16_t tangential_force1;
  uint16_t tangential_force2;
  uint16_t tangential_force3;
  uint16_t tangential_direction1;
  uint16_t tangential_direction2;
  uint16_t tangential_direction3;
  uint32_t self_proximity1;
  uint32_t self_proximity2;
  uint32_t mutual_proximity;
  uint16_t status;
};

struct TouchFingerData {
  TouchFingerItem items[5];
};

struct TurboConfig {
  uint16_t interval;
  uint16_t duration;
};

struct LedInfo {
  LedColor color;
  LedMode mode;
};

struct ButtonPressEvent {
  int32_t timestamp;
  int32_t button_id;
  PressState press_state;
};

/// Modbus异步读写回调
/// 该回调函数用于处理Modbus异步操作的结果。
/// 返回值为 0 成功，其他值失败
using ModbusOperationResultCallback = void(*)(uint8_t*, int, int, void*);

/// Modbus异步读写回调
/// 返回值为 0 成功，其他值失败
using ModbusOperationCallback = int32_t(*)(const uint8_t *values,
                                           int len,
                                           ModbusOperationResultCallback callback,
                                           void *user_data);

/// 自定义Modbus接收回调
/// 返回值为 0 成功，其他值失败
using ModbusRxCallback = int32_t(*)(uint8_t slave_id,
                                    uint16_t register_address,
                                    uint16_t *data_out,
                                    uint16_t count);

/// 自定义Modbus发送回调
/// 返回值为 0 成功，其他值失败
using ModbusTxCallback = int32_t(*)(uint8_t slave_id,
                                    uint16_t register_address,
                                    const uint16_t *data,
                                    uint16_t count);

/// CAN/CANFD 接收回调
/// 注意data_out 长度最多为 64
/// 返回值为 0 成功，其他值失败
using CanRxCallback = int32_t(*)(uint8_t slave_id,
                                 uint32_t *can_id_out,
                                 uint8_t *data_out,
                                 uintptr_t *data_len_out);

/// CAN/CANFD 发送回调
/// 返回值为 0 成功，其他值失败
using CanTxCallback = int32_t(*)(uint8_t slave_id,
                                 uint32_t can_id,
                                 const uint8_t *data,
                                 uintptr_t data_len);

/// DFU状态回调, state: DfuState
using DfuStateCallback = void(*)(uint8_t slave_id, uint8_t state);

/// DFU进度回调
using DfuProgressCallback = void(*)(uint8_t slave_id, float progress);

extern "C" {

/// 初始化选项
/// protocol_type: 协议类型，默认为 Modbus
/// log_level: 日志级别，默认为 Info
void init_cfg(StarkProtocolType protocol_type, LogLevel log_level);

/// 列出可用的串口
/// 用于列出所有的 Stark 串口
void list_available_ports();

/// 自动检测串口设备，先检测二代灵巧手，再检测一代灵巧手
/// port: 串口名称，传入 None 时自动检测
/// quick: 是否快速检测，默认为 true, 默认只检测集中特定波特率及设备ID
/// 返回 DeviceConfig 结构体指针，包含协议类型、端口名称、波特率和设备ID，关闭时需要调用 free_device_config 释放内存
/// 如果失败，返回 NULL
/// 注意：quick传false时，此函数会自动检测设备ID范围1~247，可能需要较长时间
DeviceConfig *auto_detect_device(const char *port,
                                 bool quick);

/// 自动检测一代灵巧手设备
/// port: 串口名称，传入 None 时自动检测
/// quick: 是否快速检测，默认为 true, 默认只检测集中特定波特率及设备ID
/// 返回 DeviceConfig 结构体指针，包含协议类型、端口名称、波特率和设备ID，，关闭时需要调用 free_device_config 释放内存
/// 如果失败，返回 NULL
/// 注意：quick传false时，此函数会自动检测设备ID范围1~247，可能需要较长时间
DeviceConfig *auto_detect_modbus_revo1(const char *port,
                                       bool quick);

/// 自动检测二代灵巧手设备
/// port: 串口名称，传入 None 时自动检测
/// quick: 是否快速检测，默认为 true, 默认只检测集中特定波特率及设备ID
/// 返回 DeviceConfig 结构体指针，包含协议类型、端口名称、波特率和设备ID，，关闭时需要调用 free_device_config 释放内存
/// 如果失败，返回 NULL
/// 注意：quick传false时，此函数会自动检测设备ID范围1~247，可能需要较长时间
DeviceConfig *auto_detect_modbus_revo2(const char *port,
                                       bool quick);

/// 打开串口
/// port: 串口名称，例如："/dev/ttyUSB0", "COM1"
/// baudrate: 波特率，115200, 57600, 19200, 460800，一代手默认为115200，二代手默认为460800, 二代手支持1M, 2M, 5M
/// 返回 DeviceHandler 结构体指针，关闭时需要调用 modbus_close 释放内存
/// 如果失败，返回 NULL
DeviceHandler *modbus_open(const char *port,
                           uint32_t baudrate);

/// 关闭串口
void modbus_close(DeviceHandler *handle);

/// @brief  创建一个新的 DeviceHandler 结构体
/// @return  返回指向新创建的 DeviceHandler 结构体的指针，关闭时需要调用 free_device_handler 释放内存
DeviceHandler *create_device_handler();

/// @brief  释放 DeviceHandler 结构体
/// @param handle  DeviceHandler 结构体指针
void free_device_handler(DeviceHandler *handle);

/// @brief  创建一个新的 DeviceHandler 结构体
/// @param master_id: 主设备ID，范围为1~255
/// @return  返回指向新创建的 DeviceHandler 结构体的指针，关闭时需要调用 free_device_handler 释放内存
DeviceHandler *canfd_init(uint8_t master_id);

/// 打开EtherCAT igH Master主站
DeviceHandler *ethercat_open_master(uint32_t master_pos);

/// 关闭EtherCAT igH Master主站
void ethercat_close(DeviceHandler *handle);

/// 设置EtherCAT设备的SDO
void ethercat_setup_sdo(DeviceHandler *handle, uint16_t slave_pos);

void ethercat_reserve_master(DeviceHandler *handle);

/// 开始EtherCAT循环, PDO通信控制&读取
/// dc_assign_activate: DC标志，0x0000表示不设置DC
/// sync0_cycle_time: SYNC0周期时间，单位为纳秒, loop循环周期和 SYNC0周期时间一致
/// sync0_shift_time: SYNC0相位偏移时间，单位为纳秒
/// sync1_cycle_time: SYNC1周期时间，单位为纳秒
/// sync1_shift_time: SYNC1相位偏移时间，单位为纳秒
void ethercat_start_loop(DeviceHandler *handle,
                         const uint16_t *slave_positions,
                         int count,
                         uint16_t dc_assign_activate,
                         uint32_t sync0_cycle_time,
                         int32_t sync0_shift_time,
                         uint32_t sync1_cycle_time,
                         int32_t sync1_shift_time);

/// 停止EtherCAT循环
void ethercat_stop_loop(DeviceHandler *handle);

/// EtherCAT DFU, 通过Foe协议进行固件升级
/// slave_pos: 从站位置
/// dfu_type: DFU类型，Control或Wrist
/// file_path: 固件文件路径
void ethercat_start_dfu(DeviceHandler *handle,
                        uint16_t slave_pos,
                        EtherCATFoeType dfu_type,
                        const char *file_path);

/// 获取设备信息
/// 返回 DeviceInfo 结构体指针，需要调用 free_device_info 释放内存
/// 如果失败，返回 NULL
DeviceInfo *stark_get_device_info(DeviceHandler *handle, uint8_t slave_id);

/// 根据序列号判断是否为触觉版灵巧手
bool is_touch_hand_by_sn(const char *sn_ptr);

/// 根据序列号判断是否为二代灵巧手
bool is_revo2_hand_by_sn(const char *sn_ptr);

/// 获取RS485串口设备波特率
/// 115200, 57600, 19200, 460800
uint32_t stark_get_rs485_baudrate(DeviceHandler *handle, uint8_t slave_id);

/// 设置RS485串口设备波特率
/// 115200, 57600, 19200, 460800
void stark_set_rs485_baudrate(DeviceHandler *handle, uint8_t slave_id, uint32_t baudrate);

/// 获取CANFD设备波特率
/// 1M, 2M, 4M, 5M
uint32_t stark_get_canfd_baudrate(DeviceHandler *handle, uint8_t slave_id);

/// 设置CANFD设备波特率
/// 1M, 2M, 4M, 5M
void stark_set_canfd_baudrate(DeviceHandler *handle, uint8_t slave_id, uint32_t baudrate);

/// 设置设备ID，默认为1，范围为1~247, 0 为广播地址，一代手默认为1，二代手左手默认ID为0x7e，右手默认ID为0x7f
/// 当需要在一条总线上同时控制多只设备时，需要将设备ID设置为不同的值
/// 例如：设置左手ID为1，右手ID为2
/// 通过广播地址0，可以同时控制总线上的所有设备，Mobbus协议规定广播地址的设备不会回复
void stark_set_slave_id(DeviceHandler *handle,
                        uint8_t slave_id,
                        uint8_t new_id);

/// Deprecated
/// 设置力量等级，仅支持标准版一代手
void stark_set_force_level(DeviceHandler *handle, uint8_t slave_id, ForceLevel level);

/// Deprecated
/// 获取力量等级，仅支持标准版一代手
uint8_t stark_get_force_level(DeviceHandler *handle, uint8_t slave_id);

/// 获取电压值，单位mV
uint16_t stark_get_voltage(DeviceHandler *handle, uint8_t slave_id);

/// 获取LED开关
bool get_led_enabled(DeviceHandler *handle, uint8_t slave_id);

/// 获取蜂鸣器开关
bool get_buzzer_enabled(DeviceHandler *handle, uint8_t slave_id);

/// 获取震动开关
bool get_vibration_enabled(DeviceHandler *handle, uint8_t slave_id);

/// 设置LED开关
void set_led_enabled(DeviceHandler *handle, uint8_t slave_id, bool enabled);

/// 设置蜂鸣器开关
void set_buzzer_enabled(DeviceHandler *handle, uint8_t slave_id, bool enabled);

/// 设置震动开关
void set_vibration_enabled(DeviceHandler *handle, uint8_t slave_id, bool enabled);

/// 二代手设置单位模式，手指参数，上电后重置
/// 参数范围详见文档
/// https://brainco.yuque.com/tykrbo/hws0nr/pynh5qnmfa1bgamc
/// 设置控制的单位模式
/// 无极模式，物理量模式
void stark_set_finger_unit_mode(DeviceHandler *handle, uint8_t slave_id, FingerUnitMode mode);

/// 获取控制的单位模式
/// 返回 FingerUnitMode
/// 如果失败，返回 FingerUnitMode::Normalized
FingerUnitMode stark_get_finger_unit_mode(DeviceHandler *handle, uint8_t slave_id);

/// 设置最大角度
/// max_pos: 最大角度值，默认为 60 87 84 84 84 84
void stark_set_finger_max_position(DeviceHandler *handle,
                                   uint8_t slave_id,
                                   StarkFingerId finger_id,
                                   uint16_t max_pos);

/// 设置最小角度
/// min_pos: 最小角度值，单位(°)，默认为 0 0 0 0 0 0
void stark_set_finger_min_position(DeviceHandler *handle,
                                   uint8_t slave_id,
                                   StarkFingerId finger_id,
                                   uint16_t min_pos);

/// 设置最大速度
/// max_speed: 最大速度值，单位(°/s)，默认值为 145 150 130 130 130 130
void stark_set_finger_max_speed(DeviceHandler *handle,
                                uint8_t slave_id,
                                StarkFingerId finger_id,
                                uint16_t max_speed);

/// 设置最大电流
/// max_current: 最大电流值，单位(mA)，默认值为 1000
void stark_set_finger_max_current(DeviceHandler *handle,
                                  uint8_t slave_id,
                                  StarkFingerId finger_id,
                                  uint16_t max_current);

/// 设置保护电流
/// protected_current: 保护电流值，单位(mA), 范围为 100~1500，默认值为 500 500 500 500 500 500
void stark_set_finger_protected_current(DeviceHandler *handle,
                                        uint8_t slave_id,
                                        StarkFingerId finger_id,
                                        uint16_t protected_current);

/// 读取最大角度
/// 读取失败时返回0
uint16_t stark_get_finger_max_position(DeviceHandler *handle,
                                       uint8_t slave_id,
                                       StarkFingerId finger_id);

/// 读取最小角度
/// min_pos: 最小角度值，单位(°)，默认为 0 0 0 0 0 0
uint16_t stark_get_finger_min_position(DeviceHandler *handle,
                                       uint8_t slave_id,
                                       StarkFingerId finger_id);

/// 读取最大速度
/// max_speed: 最大速度值，单位(°/s)，默认值为 145 150 130 130 130 130
/// 读取失败时返回0
uint16_t stark_get_finger_max_speed(DeviceHandler *handle,
                                    uint8_t slave_id,
                                    StarkFingerId finger_id);

/// 读取最大电流
/// max_current: 最大电流值，单位(mA)，默认值为 1000
/// 读取失败时返回0
uint16_t stark_get_finger_max_current(DeviceHandler *handle,
                                      uint8_t slave_id,
                                      StarkFingerId finger_id);

/// 读取保护电流
/// protected_current: 保护电流值，单位(mA), 范围为 100~1500，默认值为 500 500 500 500 500 500
/// 读取失败时返回0
uint16_t stark_get_finger_protected_current(DeviceHandler *handle,
                                            uint8_t slave_id,
                                            StarkFingerId finger_id);

/// 拇指 AUX 锁定电流设置
/// aux_lock_current: 单位(mA), 范围为 100~500，默认值为 200
/// 仅支持二代手
void stark_set_thumb_aux_lock_current(DeviceHandler *handle,
                                      uint8_t slave_id,
                                      uint16_t aux_lock_current);

/// 读取拇指 AUX 锁定电流设置
/// 仅支持二代手
uint16_t stark_get_thumb_aux_lock_current(DeviceHandler *handle, uint8_t slave_id);

/// 设置单个手指位置
/// position: 位置值，一代手范围为0~100
/// 二代手范围为0~1000或最小-最大位置（°）
void stark_set_finger_position(DeviceHandler *handle,
                               uint8_t slave_id,
                               StarkFingerId finger_id,
                               uint16_t position);

/// 设置单个手指速度
/// speed: 速度值，一代手范围为-100~100
/// 二代手范围为-1000~1000或-最大速度~最大速度°/s
/// 其中符号表示方向，正表示为握紧方向，负表示为松开方向。
void stark_set_finger_speed(DeviceHandler *handle,
                            uint8_t slave_id,
                            StarkFingerId finger_id,
                            int16_t speed);

/// 设置单个手指电流
/// 二代基础版，参数范围为-1000~1000或-最大电流~最大电流mA
/// 一代触觉版，参数范围为-100~-20, 20~100，单位mA
/// 其中符号表示方向，正表示为握紧方向，负表示为松开方向。
void stark_set_finger_current(DeviceHandler *handle,
                              uint8_t slave_id,
                              StarkFingerId finger_id,
                              int16_t current);

/// 设置单个手指PWM
/// 仅支持二代手
/// 范围为-1000~1000
/// 其中符号表示方向，正表示为握紧方向，负表示为松开方向。
void stark_set_finger_pwm(DeviceHandler *handle,
                          uint8_t slave_id,
                          StarkFingerId finger_id,
                          int16_t pwm);

/// 设置单个手指位置+期望时间
/// 仅支持二代手
/// 位置范围为0~1000或最小-最大位置（°）
/// 期望时间范围为1~2000ms
void stark_set_finger_position_with_millis(DeviceHandler *handle,
                                           uint8_t slave_id,
                                           StarkFingerId finger_id,
                                           uint16_t position,
                                           uint16_t millis);

/// 设置单个手指位置+期望速度
/// 仅支持二代手
/// 位置范围为0~1000或最小最大位置（°）
/// 速度范围为1~1000或最小~最大速度(°/s）
void stark_set_finger_position_with_speed(DeviceHandler *handle,
                                          uint8_t slave_id,
                                          StarkFingerId finger_id,
                                          uint16_t position,
                                          uint16_t speed);

/// 设置多个手指位置
/// positions: 位置值数组，长度为6，范围为0~100, 对应百分比位置
void stark_set_finger_positions(DeviceHandler *handle,
                                uint8_t slave_id,
                                const uint16_t *positions,
                                uintptr_t len);

/// 设置多个手指速度
/// speeds: 速度值数组，长度为6，一代手范围为-100~100
/// 二代手范围为-1000~1000或-最大速度~最大速度°/s
/// 其中符号表示方向，正表示为握紧方向，负表示为松开方向。
void stark_set_finger_speeds(DeviceHandler *handle,
                             uint8_t slave_id,
                             const int16_t *speeds,
                             uintptr_t len);

/// 设置多个手指电流
/// 二代基础版，参数范围为-1000~1000或-最大电流~最大电流mA
/// 一代触觉版，参数范围为-100~-20, 20~100，单位mA
/// 其中符号表示方向，正表示为握紧方向，负表示为松开方向。
void stark_set_finger_currents(DeviceHandler *handle,
                               uint8_t slave_id,
                               const int16_t *currents,
                               uintptr_t len);

/// 设置多个手指PWM
/// 仅支持二代手
/// pwms: PWM值数组，长度为6，范围为-1000~1000
/// 其中符号表示方向，正表示为握紧方向，负表示为松开方向。
void stark_set_finger_pwms(DeviceHandler *handle,
                           uint8_t slave_id,
                           const int16_t *pwms,
                           uintptr_t len);

/// 设置多个手指位置+期望时间
/// 仅支持二代手
/// positions: 位置值数组，长度为6，范围为0~1000或最小~最大位置（°）
/// millis: 期望时间值数组，长度为6，范围为1~2000ms
/// 其中位置值和期望时间值一一对应
void stark_set_finger_positions_and_durations(DeviceHandler *handle,
                                              uint8_t slave_id,
                                              const uint16_t *positions,
                                              const uint16_t *millis,
                                              uintptr_t len);

/// 设置多个手指位置+期望速度
/// 仅支持二代手
/// positions: 位置值数组，长度为6，范围为0~1000或最小最大位置（°）
/// speeds: 速度值数组，长度为6，范围为1~1000或最小~最大速度(°/s)
/// 其中位置值和速度值一一对应
void stark_set_finger_positions_and_speeds(DeviceHandler *handle,
                                           uint8_t slave_id,
                                           const uint16_t *positions,
                                           const uint16_t *speeds,
                                           uintptr_t len);

/// 获取手指状态
/// 位置、速度、电流、马达运行状态
/// 返回 MotorStatusData 结构体指针，需要调用 free_motor_status_data 释放内存
/// 如果失败，返回 NULL
MotorStatusData *stark_get_motor_status(DeviceHandler *handle, uint8_t slave_id);

/// 运行动作序列
/// action_id: 动作序列ID
void stark_run_action_sequence(DeviceHandler *handle, uint8_t slave_id, ActionSequenceId action_id);

/// 传输动作序列
///
/// 该函数用于传输多个动作序列。每个动作序列包含 20 个元素，依次为：
///
/// - action_id: 动作序列的 ID，用于唯一标识该动作序列
/// - sequences: 动作序列参数数组，包含多个动作序列
///
/// 一代灵巧手每个动作序列包含 20 个 u16 元素。每个序列包括以下信息：
///   - 动作序列索引 (u16)：动作序列的索引，用于标识该动作序列在队列中的位置
///   - 持续时间 (u16)：该动作序列的执行时间，单位为毫秒
///   - 手指位置 (u16): 6 个手指位置的值，范围为 0~100
///   - 手指速度 (u16): 6 个手指速度的值，范围为 0~100
///   - 手指力量 (u16): 6 个手指力量的值，范围为 0~100
///
/// 示例：
/// 假设我们有以下动作序列数组：
/// [0, 2000, 0, 0, 100, 100, 100, 100, 10, 20, 30, 40, 50, 60, 5, 10, 15, 20, 25, 30]
///
/// 解释：
/// - `0`: 动作序列索引
/// - `2000`: 动作序列持续时间，单位毫秒
/// - `0, 0, 100, 100, 100, 100`: 6 个手指位置
/// - `10, 20, 30, 40, 50, 60`: 6 个手指速度
/// - `5, 10, 15, 20, 25, 30`: 6 个手指力量
///
/// 二代灵巧手每个动作序列包含 27 个 u16 元素。每个序列包括以下信息：
///   - 动作序列索引 (u16)：动作序列的索引，用于标识该动作序列在队列中的位置
///   - 持续时间 (u16)：该动作序列的执行时间，单位为毫秒
///   - 控制模式 (u16), 位置时间控制：1，位置速度控制：2，电流控制：3，速度控制：4
///   - 手指位置 (u16): 6 个手指位置的物理量（°）, 值为 65535 (0xFFFF) 表示手指保持原来角度
///   - 手指速度 (u16): 6 个手指速度的物理量，值为手指转动速度（°/s）
///   - 手指电流 (u16): 6 个手指电流的物理量，值为电流(mA)
///
/// - len: 动作序列的数量，指定 sequences 数组的行数，即动作序列的数量
///
/// # 参数说明
/// - `action_id`: 动作序列的 ID，唯一标识该序列
/// - `sequences`: 一个指向动作序列的指针，表示多个动作序列的二维数组
/// - `len`: 动作序列的数量，表示二维数组的行数
///
/// # 错误处理
/// - 如果 `handle` 或 `sequences` 为 NULL，将直接返回，不进行处理
/// - 如果 `len` 大于最大限制（一代灵巧手为32，二代灵巧手为8），会输出警告并提前返回
void stark_set_action_sequence(DeviceHandler *handle,
                               uint8_t slave_id,
                               ActionSequenceId action_id,
                               const uint16_t *sequences,
                               uintptr_t len);

/// 启用触觉传感器
/// bits: 启用的触觉传感器位，范围为0~31
/// 例如：0b00000001 表示仅启用大拇指位置的触觉传感器
void stark_enable_touch_sensor(DeviceHandler *handle, uint8_t slave_id, uint8_t bits);

/// 获取触觉传感器通道数据
/// 返回 TouchRawData 结构体指针，需要调用 free_touch_raw_data 释放内存
/// 如果失败，返回 NULL
TouchRawData *stark_get_touch_raw_data(DeviceHandler *handle, uint8_t slave_id);

/// 读取单个手指三维力、接近值、触觉传感器状态
/// 返回单个手指三维力、接近值、触觉传感器状态
/// index: 0~4，分别对应大拇指、食指、中指、无名指、小拇指
/// 使用完毕后需要调用 free_touch_finger_item 释放内存
/// 如果失败，返回 NULL
TouchFingerItem *stark_get_single_touch_status(DeviceHandler *handle,
                                               uint8_t slave_id,
                                               uint8_t index);

/// 读取五指触觉传感器三维力、接近值、触觉传感器状态
/// 返回五指的触觉三维力数据、接近值、触觉传感器状态
/// 使用完毕后需要调用 free_touch_finger_data 释放内存
/// 如果失败，返回 NULL
TouchFingerData *stark_get_touch_status(DeviceHandler *handle, uint8_t slave_id);

/// 重置触觉传感器采集通道
/// 在执行该指令时，手指传感器尽量不要受力。
/// bits: 重置的触觉传感器位，范围为0~31
/// 例如：0b00000001 表示重置第一个传感器
void stark_reset_touch_sensor(DeviceHandler *handle, uint8_t slave_id, uint8_t bits);

/// 触觉传感器参数校准
/// bits: 校准的触觉传感器位，范围为0~31
/// 例如：0b00000001 表示校准第一个传感器
/// 当空闲状态下的三维力数值不为0时，可通过该方法进行校准
/// https://www.brainco-hz.com/docs/revolimb-hand/protocol/stark_protocol_touch.html#_5-3-%E5%8F%82%E6%95%B0%E6%A0%A1%E5%87%864105
void stark_calibrate_touch_sensor(DeviceHandler *handle,
                                  uint8_t slave_id,
                                  uint8_t bits);

/// 在设备上电时，启用/禁用 位置自动校准
bool stark_get_auto_calibration(DeviceHandler *handle, uint8_t slave_id);

/// 在设备上电时，启用/禁用 位置自动校准
void stark_set_auto_calibration(DeviceHandler *handle, uint8_t slave_id, bool enabled);

/// 发送校准位置指令
/// 用于手动校准位置
void stark_send_calibrate_position(DeviceHandler *handle, uint8_t slave_id);

/// 重置默认手势
/// 该指令会将所有手势恢复为出厂默认值
void stark_reset_default_gesture(DeviceHandler *handle, uint8_t slave_id);

/// 重置默认设置
/// 该指令会将所有设置恢复为出厂默认值
/// ● 默认ID：左手 → 恢复为 0x7E（126）；右手 → 恢复为 0x7F（127）
/// ● RS485 波特率：恢复为 460800 bps。
/// ● CAN FD 波特率：恢复为 5 Mbps
void stark_reset_default_settings(DeviceHandler *handle, uint8_t slave_id);

/// 是否开启了 Turbo 模式
/// 开启之后会持续握紧
bool stark_get_turbo_mode_enabled(DeviceHandler *handle, uint8_t slave_id);

/// 设置 Turbo 模式
void stark_set_turbo_mode_enabled(DeviceHandler *handle, uint8_t slave_id, bool enabled);

/// 获取 Turbo 模式配置
/// 返回 TurboConfig 结构体指针，需要调用 free_turbo_config 释放内存
/// 如果失败，返回 NULL
TurboConfig *stark_get_turbo_config(DeviceHandler *handle, uint8_t slave_id);

/// 获取 LED 灯信息
/// 返回 LedInfo 结构体指针，需要调用 free_led_info 释放内存
/// 如果失败，返回 NULL
LedInfo *stark_get_led_info(DeviceHandler *handle, uint8_t slave_id);

/// 获取按键事件
/// 返回 ButtonPressEvent 结构体指针，需要调用 free_button_event 释放内存
/// 如果失败，返回 NULL
ButtonPressEvent *stark_get_button_event(DeviceHandler *handle, uint8_t slave_id);

/// 该函数用于启动 DFU（Device Firmware Update）过程。
/// - `handle`: 设备处理器指针
/// - `slave_id`: 从设备 ID
/// - `dfu_file_path`: DFU 文件路径，C 字符串格式
/// - `wait_secs`: 等待进入DFU模式时间，单位为秒，默认为5秒
void start_dfu(DeviceHandler *handle,
               uint8_t slave_id,
               const char *dfu_file_path,
               uintptr_t wait_secs);

/// 停止 DFU 过程
/// - `slave_id`: 从设备 ID
/// 该函数用于停止 DFU 过程。
/// 注意：在调用此函数之前，请确保 DFU 过程已经开始。
/// 如果 DFU 过程未开始或已经完成，此函数将不会有任何效果。
void stop_dfu(uint8_t slave_id);

void free_device_config(DeviceConfig *config);

void free_device_info(DeviceInfo *info);

void free_motor_status_data(MotorStatusData *data);

void free_touch_raw_data(TouchRawData *data);

void free_touch_finger_data(TouchFingerData *status);

void free_touch_finger_item(TouchFingerItem *item);

void free_turbo_config(TurboConfig *config);

void free_led_info(LedInfo *info);

void free_button_event(ButtonPressEvent *event);

void free_string(const char *s);

/// 设置Modbus异步读写回调
void set_modbus_operation_callback(ModbusOperationCallback cb);

/// 设置Modbus读回调, input_registers
void set_modbus_read_input_callback(ModbusRxCallback cb);

/// 设置Modbus读回调, holding_registers
void set_modbus_read_holding_callback(ModbusRxCallback cb);

/// 设置Modbus写回调
void set_modbus_write_callback(ModbusTxCallback cb);

/// 设置CAN/CANFD 读回调
void set_can_rx_callback(CanRxCallback cb);

/// 设置CAN/CANFD 写回调
void set_can_tx_callback(CanTxCallback cb);

/// 设置DFU状态回调
void set_dfu_state_callback(DfuStateCallback cb);

/// 设置DFU进度回调
void set_dfu_progress_callback(DfuProgressCallback cb);

}  // extern "C"

#endif  // STARK_SDK_H
